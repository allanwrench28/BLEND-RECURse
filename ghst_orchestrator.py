#!/usr/bin/env python3
"""
GHST Orchestrator (prototype)

Purpose: allow a human to type a messy, layman prompt and have a GHST think-tank
ask clarifying questions, produce a short spec, and scaffold starter code with
minimal human interaction. This is a local, template-driven prototype that can
later be extended to call an LLM or other code generators.

Usage:
  python ghst_orchestrator.py        # interactive
  python ghst_orchestrator.py --demo # run a demo with a messy prompt
"""
from __future__ import annotations

import json
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict


def ask(question: str, default: str = "") -> str:
    try:
        resp = input(f"{question} ")
    except KeyboardInterrupt:
        print()
        sys.exit(1)
    if not resp:
        return default
    return resp


def sanitize_name(s: str) -> str:
    return ''.join(c if c.isalnum() or c == '_' else '_' for c in s.strip()).lower()


TEMPLATES = {
    'web': '''#!/usr/bin/env python3
"""Simple Flask TODO API (generated by GHST Orchestrator)"""
from flask import Flask, request, jsonify

app = Flask(__name__)
todos = []

@app.route('/todos', methods=['GET'])
def list_todos():
    return jsonify(todos)

@app.route('/todos', methods=['POST'])
def add_todo():
    data = request.get_json() or {}
    todo = {'id': len(todos)+1, 'title': data.get('title',''), 'done': False}
    todos.append(todo)
    return jsonify(todo), 201

if __name__ == '__main__':
    app.run(port=5000)
''',

    'cli': '''#!/usr/bin/env python3
"""Simple CLI utility (generated by GHST Orchestrator)"""
import argparse

def main():
    p = argparse.ArgumentParser()
    p.add_argument('--name', default='world')
    args = p.parse_args()
    print(f'Hello, {args.name}!')

if __name__ == '__main__':
    main()
''',

    'lib': '''"""Library module (generated by GHST Orchestrator)"""
def greet(name: str) -> str:
    return f'Hello, {name}!'
''',
}


def scaffold(spec: Dict) -> Path:
    outdir = Path('generated')
    outdir.mkdir(parents=True, exist_ok=True)
    name = sanitize_name(spec.get('name', 'ghst_task'))
    kind = spec.get('kind', 'cli')
    filename = outdir / f"{name}.py"
    tpl = TEMPLATES.get(kind, TEMPLATES['cli'])
    banner = f"# Generated by GHST Orchestrator on {datetime.utcnow().isoformat()}Z\n"
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(banner)
        f.write(tpl)
    return filename


def run_demo():
    messy = "make me a damn todo rest api with auth and save shit to a file, i dont care about tests"
    print('User prompt (messy):')
    print('  ' + messy)
    print('\nGHST think-tank is asking clarifying questions...')
    # simulated clarifying Qs (automated answers for demo)
    answers = {}
    answers['name'] = 'Todo API'
    answers['language'] = 'python'
    answers['kind'] = 'web'
    answers['persistence'] = 'file'
    answers['auth'] = 'no'
    spec = {
        'prompt': messy,
        'name': answers['name'],
        'language': answers['language'],
        'kind': answers['kind'],
        'persistence': answers['persistence'],
        'auth': answers['auth'],
        'timestamp': datetime.utcnow().isoformat() + 'Z',
    }
    tasks = Path('tasks')
    tasks.mkdir(exist_ok=True)
    specf = tasks / f"spec_{sanitize_name(spec['name'])}.json"
    with open(specf, 'w', encoding='utf-8') as f:
        json.dump(spec, f, indent=2)
    print('\nSpec saved to', specf)
    generated = scaffold(spec)
    print('Scaffolded starter code to', generated)
    print('\nNext steps: review the generated file, run it, and the GHST fixer can tidy it.')
    return 0


def interactive():
    print('GHST Orchestrator — type a messy prompt (layman language). Ctrl-C to exit.')
    prompt = ask('Describe what you want:')
    if not prompt:
        print('No prompt provided; exiting')
        return 1
    print('\nGHST: a few quick clarifying questions...')
    name = ask('Name for this project (short):', default='GHSTTask')
    language = ask('Target language [python]:', default='python')
    kind = ask('Kind [web/cli/lib]:', default='cli')
    persistence = ask('Persistence [none/file/sql]:', default='none')
    auth = ask('Auth required? [yes/no]:', default='no')
    spec = {
        'prompt': prompt,
        'name': name,
        'language': language,
        'kind': kind,
        'persistence': persistence,
        'auth': auth,
        'timestamp': datetime.utcnow().isoformat() + 'Z',
    }
    tasks = Path('tasks')
    tasks.mkdir(exist_ok=True)
    specf = tasks / f"spec_{sanitize_name(spec['name'])}.json"
    with open(specf, 'w', encoding='utf-8') as f:
        json.dump(spec, f, indent=2)
    print('\nSpec saved to', specf)
    generated = scaffold(spec)
    print('Scaffolded starter code to', generated)
    print('\nReview the file and run it; GHST fixer can tidy the code.')
    return 0


def generate_clarifying_questions(prompt: str) -> list:
    """Heuristic clarifying questions derived from the messy prompt."""
    q = []
    # always ask for a short name
    q.append(("Name for this project (short)", "GHSTTask"))
    # language
    if 'python' in prompt.lower() or 'flask' in prompt.lower() or 'django' in prompt.lower():
        q.append(("Target language", "python"))
    else:
        q.append(("Target language", "python"))
    # kind
    if 'api' in prompt.lower() or 'rest' in prompt.lower() or 'server' in prompt.lower():
        q.append(("Kind [web/cli/lib]", "web"))
    elif 'cli' in prompt.lower() or 'script' in prompt.lower():
        q.append(("Kind [web/cli/lib]", "cli"))
    else:
        q.append(("Kind [web/cli/lib]", "cli"))
    # persistence
    if 'file' in prompt.lower() or 'save' in prompt.lower():
        q.append(("Persistence [none/file/sql]", "file"))
    else:
        q.append(("Persistence [none/file/sql]", "none"))
    # auth
    if 'auth' in prompt.lower() or 'login' in prompt.lower() or 'user' in prompt.lower():
        q.append(("Auth required? [yes/no]", "no"))
    else:
        q.append(("Auth required? [yes/no]", "no"))
    # tests
    q.append(("Include tests? [yes/no]", "no"))
    # python version
    q.append(("Python version (e.g. 3.11)", "3.11"))
    # CI
    q.append(("Create CI workflow? [yes/no]", "no"))
    return q


def estimate_confidence(prompt: str) -> Dict[str, float]:
    """Return heuristic confidences (0..1) for key aspects based on prompt keywords.

    Higher score means we are confident we understood the user's intent for that field.
    """
    s = prompt.lower()
    def any_kw(ks):
        return any(k in s for k in ks)

    confidences = {}
    # language confidence
    confidences['language'] = 1.0 if any_kw(['python', 'flask', 'django']) else 0.5
    # kind confidence
    confidences['kind'] = 1.0 if any_kw(['api', 'rest', 'server', 'cli']) else 0.5
    # persistence confidence
    confidences['persistence'] = 1.0 if any_kw(['save', 'file', 'db', 'sqlite', 'postgres']) else 0.3
    # auth confidence
    confidences['auth'] = 1.0 if any_kw(['auth', 'login', 'signup', 'user']) else 0.2
    # tests confidence
    confidences['tests'] = 1.0 if any_kw(['test', 'tests', 'pytest']) else 0.3
    # ci confidence
    confidences['ci'] = 1.0 if any_kw(['ci', 'github actions', 'gitlab', 'workflow']) else 0.2
    return confidences


def autopilot(prompt: str | None = None, auto_apply: bool = False, question_threshold: float = 0.4) -> int:
    """Autopilot flow: user gives messy prompt, GHSTs ask clarifying Qs, scaffold, optional fixer dry-run."""
    if not prompt:
        try:
            prompt = input('Give your messy prompt: ')
        except KeyboardInterrupt:
            print()
            return 1
    print('\nGHST think-tank received prompt:')
    print('  ' + prompt)
    # generate clarifying questions
    questions = generate_clarifying_questions(prompt)
    confidences = estimate_confidence(prompt)
    answers = {}
    print('\nGHSTs: clarifying questions — only asked if confidence < {0}'.format(question_threshold))
    # map simple keys to confidence fields
    field_map = {
        'Name': None,
        'Target': 'language',
        'Kind': 'kind',
        'Persistence': 'persistence',
        'Auth': 'auth',
        'Include': 'tests',
        'Python': None,
        'Create': 'ci',
    }
    for q, default in questions:
        # extract a short key
        key = q.split()[0].capitalize()
        conf_field = field_map.get(key)
        if conf_field is None:
            # always ask name and python version
            a = ask(f"{q} [{default}]:", default=default)
        else:
            conf = confidences.get(conf_field, 0.0)
            if conf >= question_threshold:
                # accept default without asking
                a = default
                print(f"(Auto) {q} -> {a}")
            else:
                a = ask(f"{q} [{default}]:", default=default)
        answers_key = q.split()[0].lower()
        answers[answers_key] = a or default

    # normalize into spec fields used by scaffold
    spec = {
        'prompt': prompt,
        'name': answers.get('name', answers.get('name', 'GHSTTask')),
        'language': answers.get('target', 'python'),
        'kind': answers.get('kind', 'cli'),
        'persistence': answers.get('persistence', 'none'),
        'auth': answers.get('auth', 'no'),
        'tests': answers.get('include', 'no'),
        'python_version': answers.get('python', '3.11'),
        'ci': answers.get('create', 'no'),
        'timestamp': datetime.utcnow().isoformat() + 'Z',
    }

    tasks = Path('tasks')
    tasks.mkdir(exist_ok=True)
    specf = tasks / f"spec_{sanitize_name(spec['name'])}.json"
    with open(specf, 'w', encoding='utf-8') as f:
        json.dump(spec, f, indent=2)
    print('\nSpec saved to', specf)
    generated = scaffold(spec)
    print('Scaffolded starter code to', generated)

    # run fixer dry-run automatically to polish
    print('\nRunning GHST fixer in dry-run to preview polish...')
    subprocess.run([sys.executable, 'ghst_agent.py', 'fix-once', '--dry-run'])

    if auto_apply:
        yn = ask('Apply fixes automatically now? [yes/no]', default='no')
        if yn.lower().startswith('y'):
            subprocess.run([sys.executable, 'ghst_agent.py', 'fix-once'])

    print('\nAutopilot finished — review generated files under ./generated and ./tasks')
    return 0


def main(argv=None):
    argv = argv or sys.argv[1:]
    if '--demo' in argv:
        return run_demo()
    return interactive()


if __name__ == '__main__':
    sys.exit(main())
